# -*- coding: utf-8 -*-
"""IRWA_Lab04.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Efjrk7HiVX5ZJ3ROWU_CrdcZD17XxJKv
"""

from nltk.util import ngrams

text="April is the best month"
text_new="$"+"April is the best month".replace(" ","$")+"$"
print(text_new)

g2=ngrams(text_new,2)
g2list=["".join(i) for i in g2]
print(g2list)

def jaccard(x,y):
  a=x.intersection(y)
  b=x.union(y)
  return len(a)/len(b)

from nltk.metrics.distance import edit_distance

print(edit_distance('python','pythonly'))

!pip install Levenshtein

from Levenshtein import distance

print(distance('python','pythonly'))

def soundex(word: str) -> str:
  """
  Soundex implementation (slide version):
    1) Retain first letter (uppercase).
    2) Change A,E,I,O,U,H,W,Y -> '0'
    3) Map letters to digits:
          B,F,P,V -> 1
          C,G,J,K,Q,S,X,Z -> 2
          D,T -> 3
          L -> 4
          M,N -> 5
          R -> 6
    4) Remove pairs of consecutive duplicate digits.
    5) Remove all zeros.
    6) Pad with trailing zeros and return first four characters: LDDD
  """
  if not word:
      return "0000"

  w = word.strip()
  if not w:
      return "0000"
  first = w[0].upper()
  groups = {
      'B': '1', 'F': '1', 'P': '1', 'V': '1',
      'C': '2', 'G': '2', 'J': '2', 'K': '2',
      'Q': '2', 'S': '2', 'X': '2', 'Z': '2',
      'D': '3', 'T': '3',
      'L': '4',
      'M': '5', 'N': '5',
      'R': '6'
  }
  zeros = set("AEIOUHWY")
  encoded = []
  for ch in w[1:].upper():
      if ch in zeros:
          encoded.append('0')
      else:
          encoded.append(groups.get(ch, ''))
  dedup = []
  last = None
  for d in encoded:
      if d == '' :
          continue
      if d != last:
          dedup.append(d)
          last = d
  dedup_no_zeros = [d for d in dedup if d != '0']
  code = first + "".join(dedup_no_zeros)
  code = (code + "0000")[:4]
  return code

print(soundex("Herman"))
print(soundex("Hermann"))



"""# Task
Create a Python function that builds an inverted index from a list of documents.

## Define the function structure

### Subtask:
Create a Python function that accepts a list of documents as input and will be used to build an inverted index.

**Reasoning**:
Define the function `build_inverted_index` with a docstring as specified in the instructions.
"""

def build_inverted_index(documents):
  """
  Builds an inverted index from a list of documents.
  """
  pass

"""## Tokenize and preprocess documents

### Subtask:
Inside the function, iterate through the documents, tokenize the text, and perform any necessary preprocessing (e.g., lowercasing, removing punctuation).

**Reasoning**:
Implement the preprocessing steps within the `build_inverted_index` function as described in the instructions.
"""

import string

def build_inverted_index(documents):
  """
  Builds an inverted index from a list of documents.
  """
  inverted_index = {}
  translator = str.maketrans('', '', string.punctuation)

  for doc_id, document in enumerate(documents):
    # Lowercase the document
    document = document.lower()

    # Remove punctuation
    document = document.translate(translator)

    # Tokenize the document
    words = document.split()

  pass

"""## Build the inverted index

### Subtask:
Create a dictionary to store the inverted index, where keys are terms and values are lists of document IDs containing that term.

**Reasoning**:
Initialize an empty dictionary `inverted_index` within the function as instructed.
"""

import string

def build_inverted_index(documents):
  """
  Builds an inverted index from a list of documents.
  """
  inverted_index = {}
  translator = str.maketrans('', '', string.punctuation)

  for doc_id, document in enumerate(documents):
    # Lowercase the document
    document = document.lower()

    # Remove punctuation
    document = document.translate(translator)

    # Tokenize the document
    words = document.split()

  return inverted_index